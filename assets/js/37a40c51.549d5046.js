"use strict";(self.webpackChunkevo_lua_github_io=self.webpackChunkevo_lua_github_io||[]).push([[9916],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(a),m=i,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||r;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5539:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var n=a(7462),i=(a(7294),a(3905));const r={},o="RFC: HTTP Protocol Implementation",l={unversionedId:"background-information/design/drafts/http-protocol",id:"background-information/design/drafts/http-protocol",title:"RFC: HTTP Protocol Implementation",description:"This document outlines the design for Evo's HTTP implementation",source:"@site/docs/background-information/design/drafts/http-protocol.md",sourceDirName:"background-information/design/drafts",slug:"/background-information/design/drafts/http-protocol",permalink:"/docs/background-information/design/drafts/http-protocol",draft:!1,editUrl:"https://github.com/evo-lua/evo-lua.github.io/edit/main/docs/background-information/design/drafts/http-protocol.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Drafts",permalink:"/docs/category/drafts"},next:{title:"RFC: Standardized Logging Framework",permalink:"/docs/background-information/design/drafts/logging-framework"}},s={},u=[{value:"Motivation",id:"motivation",level:2},{value:"Goals",id:"goals",level:2},{value:"Design Decisions",id:"design-decisions",level:2},{value:"Evaluation",id:"evaluation",level:2},{value:"Alternatives",id:"alternatives",level:2}],p={toc:u},c="wrapper";function d(e){let{components:t,...a}=e;return(0,i.kt)(c,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"rfc-http-protocol-implementation"},"RFC: HTTP Protocol Implementation"),(0,i.kt)("p",null,"This document outlines the design for Evo's HTTP implementation"),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,"HTTP protocol support is absolutely mandatory for any modern language ecosystem and therefore not optional. It's also especially important for one of the projects I'm personally working on, with said project being one of the main reasons for developing a customized runtime in the first place. There are several issues with the existing Lua implementations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Most standard implementations will not easily integrate with the libuv-based event loop"),(0,i.kt)("li",{parentName:"ul"},"Said event loop (and other libuv APIs) are a core feature of the runtime and cannot be stripped away"),(0,i.kt)("li",{parentName:"ul"},"There's also the questions of security, performance, maintenance status, and cross platform compatiblity"),(0,i.kt)("li",{parentName:"ul"},"All other implementations that I have surveyed did not inspire confidence in this regard")),(0,i.kt)("p",null,"Since Evo is a purely LuaJIT-based platform, of course there are native libraries to consider as well. However:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Anything "large and complicated" should be avoided, as any viable solution must neatly integrate with the runtime'),(0,i.kt)("li",{parentName:"ul"},"All C++ libraries I would rather avoid, due to lack of familiarity with the technology but also for ease of integration"),(0,i.kt)("li",{parentName:"ul"},"If a library doesn't have at least good documentation and sees regular updates, I can't justify its inclusion at all"),(0,i.kt)("li",{parentName:"ul"},"If not battle-tested extensively, it is doubtful whether it can be considered secure and performant enough"),(0,i.kt)("li",{parentName:"ul"},"Most libraries do not seem to integrate with libuv's event loop, often featuring their own loop controls")),(0,i.kt)("p",null,"Given all of the above concerns, precious few libraries were left that seemed like they might be a good fit"),(0,i.kt)("h2",{id:"goals"},"Goals"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Must have a battle-tested implementation, so that there's a higher chance of it being secure"),(0,i.kt)("li",{parentName:"ul"},"Must have decent documentation and/or a responsive, active maintainer team that inspires confidence"),(0,i.kt)("li",{parentName:"ul"},"Competitive performance, which essentially excludes any pure Lua implementation right out of the gate"),(0,i.kt)("li",{parentName:"ul"},"Reinvent as little of the wheel as possible (ideally, just some glue code and high-level APIs)"),(0,i.kt)("li",{parentName:"ul"},"Must not complicate the build process disproportionately for the perceived benefit (not another OpenSSL, ",(0,i.kt)("em",{parentName:"li"},"please"),")"),(0,i.kt)("li",{parentName:"ul"},"Needless to say, it must be made available for free and under a compatible (and permissive) open-source license")),(0,i.kt)("h2",{id:"design-decisions"},"Design Decisions"),(0,i.kt)("p",null,"After much research and experimentation, the following crystallized as the simplest design that fulfills all requirements:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HTTP parsing will be handled by NodeJS' ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nodejs/llhttp"},"llhttp")," library, which is to be loaded via custom LuaJIT FFI bindings"),(0,i.kt)("li",{parentName:"ul"},"Since llhttp's API is push-style and demands callbacks from C to Lua, this needs a thin wrapper layer (written in C)"),(0,i.kt)("li",{parentName:"ul"},"This wrapper is extremely minimal and only serves to store the message details in a form that Lua can read"),(0,i.kt)("li",{parentName:"ul"},"Lua should then query the state after each parsing step to trigger events inside the runtime"),(0,i.kt)("li",{parentName:"ul"},"One parser per HTTP connection should be used, as sharing them may complicate the design too much")),(0,i.kt)("h2",{id:"evaluation"},"Evaluation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"NodeJS is a usage scenario very closely related to Luvit (and therefore Luvi/Evo), so using their parser is a great fit"),(0,i.kt)("li",{parentName:"ul"},"The NodeJS team has a vested interest in keeping their parser updated and secure, as well as to accept reports/fixes"),(0,i.kt)("li",{parentName:"ul"},"Its performance is excellent and there appears to be little overhead even when using it via the FFI"),(0,i.kt)("li",{parentName:"ul"},'However, the callback issue is a real bummer that kills performance of any "naive" implementation'),(0,i.kt)("li",{parentName:"ul"},"Luckily, Mike Pall himself has posted instructions for how to circumvent the FFI-callback issue in principle"),(0,i.kt)("li",{parentName:"ul"},"Therefore the only issue is with writing a thin wrapper in C that must briefly store excess data (needs benchmarking)"),(0,i.kt)("li",{parentName:"ul"},"It's trivial to write a FFI wrapper for llhttp and the build process is dead simple, too")),(0,i.kt)("h2",{id:"alternatives"},"Alternatives"),(0,i.kt)("p",null,"The following alternatives have been considered and (at least partially) explored before settling on a decision:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use Luvit's ",(0,i.kt)("inlineCode",{parentName:"li"},"http")," library (extremely slow, probably insecure, not actively developed, questionable API design)"),(0,i.kt)("li",{parentName:"ul"},"Embed a native HTTP/WS library and let it do all of the heavy lifting (cannot integrate with libuv's event loop cleanly)")),(0,i.kt)("p",null,"While some of the ideas seemed promising at first, in practice they turned out to be more hassle than they are worth."))}d.isMDXComponent=!0}}]);