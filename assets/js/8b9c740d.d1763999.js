"use strict";(self.webpackChunkevo_lua_github_io=self.webpackChunkevo_lua_github_io||[]).push([[4920],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=u(n),p=o,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||r;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4921:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:300},i="Overview: Core Concepts",s={unversionedId:"getting-started/core-concepts",id:"getting-started/core-concepts",title:"Overview: Core Concepts",description:"Discover the fundamental concepts that differentiate Evo from Lua(JIT)",source:"@site/docs/getting-started/core-concepts.md",sourceDirName:"getting-started",slug:"/getting-started/core-concepts",permalink:"/docs/getting-started/core-concepts",draft:!1,editUrl:"https://github.com/evo-lua/evo-lua.github.io/edit/main/docs/getting-started/core-concepts.md",tags:[],version:"current",sidebarPosition:300,frontMatter:{sidebar_position:300},sidebar:"tutorialSidebar",previous:{title:"Setup: Installation and Usage",permalink:"/docs/getting-started/installation"},next:{title:"How-to Guides",permalink:"/docs/category/how-to-guides"}},l={},u=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Topics Covered",id:"topics-covered",level:2},{value:"Asynchronous I/O and the Event Loop",id:"asynchronous-io-and-the-event-loop",level:2},{value:"Events and Callbacks",id:"events-and-callbacks",level:2},{value:"Multithreading and the Event Loop",id:"multithreading-and-the-event-loop",level:2},{value:"Coroutines and the Event Loop",id:"coroutines-and-the-event-loop",level:2}],c={toc:u},h="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(h,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"overview-core-concepts"},"Overview: Core Concepts"),(0,o.kt)("p",null,"Discover the fundamental concepts that differentiate Evo from Lua(JIT)"),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"This introduction assumes you've read through both the ",(0,o.kt)("a",{parentName:"p",href:"https://www.lua.org/pil/"},"Lua")," and ",(0,o.kt)("a",{parentName:"p",href:"https://luajit.org"},"LuaJIT")," docs and are somewhat familiar with Lua programming."),(0,o.kt)("h2",{id:"topics-covered"},"Topics Covered"),(0,o.kt)("p",null,"We'll take a brief look at the most important \"new\" concepts that you'll need to be aware of when working with Evo:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Asynchronous I/O and the event loop"),(0,o.kt)("li",{parentName:"ul"},"Events and callback handlers"),(0,o.kt)("li",{parentName:"ul"},"Multithreading vs. asynchronicity"),(0,o.kt)("li",{parentName:"ul"},"Coroutines vs. asynchronicity")),(0,o.kt)("p",null,"If you're already familiar with the above, (e.g., from working with NodeJS, Luvit, or other asynchronous runtimes), feel free to skip this."),(0,o.kt)("h2",{id:"asynchronous-io-and-the-event-loop"},"Asynchronous I/O and the Event Loop"),(0,o.kt)("p",null,"Evo is designed for asynchronous programming, which allows you to perform multiple tasks concurrently without blocking the main execution thread. This is achieved using an event loop, which schedules and manages I/O operations and other tasks, running them when they're ready to execute. This approach is identical to that used by other runtimes, and it uses the exact same mechanism as ",(0,o.kt)("a",{parentName:"p",href:"https://nodejs.org/en/docs/guides/blocking-vs-non-blocking"},"NodeJS")," - in fact, it uses the ",(0,o.kt)("a",{parentName:"p",href:"https://libuv.org/"},"exact same underlying library")," to implement this functionality via ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/luvit/luv"},"Lua bindings")," to its API."),(0,o.kt)("p",null,"In contrast to synchronous or blocking code, where the execution waits for a task to complete before moving to the next one, asynchronous code can continue executing other tasks while waiting for the completion of a long-running operation. The flipside of this is that it can be more difficult to write, understand, and debug as it frequently involves callbacks, events, or a similar mechanism."),(0,o.kt)("p",null,"This overall design completely changes how Lua programs are executed in the background, at least those that use the asynchronous features included with the runtime. The standard ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/luvit/luv"},"Lua")," libraries are synchronous and you can decide for yourself when, where, and to what extent you rely on non-blocking code. Blocking generally inhibits scalability as no other work can complete, but it's still available."),(0,o.kt)("p",null,"It should be noted that only some workloads benefit from being made asynchronous:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"I/O-bound tasks such as file system access or networking are almost always",(0,o.kt)("sup",{parentName:"li",id:"fnref-1"},(0,o.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," better done asynchronously"),(0,o.kt)("li",{parentName:"ul"},"CPI-bound tasks such as heavy computation work or decompression are almost always ",(0,o.kt)("sup",{parentName:"li",id:"fnref-2"},(0,o.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," better done synchronously")),(0,o.kt)("p",null,(0,o.kt)("sup",{parentName:"p",id:"fnref-1"},(0,o.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," ",(0,o.kt)("em",{parentName:"p"},"Almost, because there is overhead for off-loading the work, and it only makes sense when you don't need the result to proceed")),(0,o.kt)("p",null,(0,o.kt)("sup",{parentName:"p",id:"fnref-2"},(0,o.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," ",(0,o.kt)("em",{parentName:"p"},"Almost, because they often require the same CPU time (just on a different thread) and the number of background workers is limited")),(0,o.kt)("h2",{id:"events-and-callbacks"},"Events and Callbacks"),(0,o.kt)("p",null,'At the lowest level, there\'s always some sort of callback (or interrupt) mechanism to notify applications of completion events. A "callback" is really just a function that will be called when the given event occurs, such as "your file has been read" or "the client sent some data". They\'re ubiquitous in languages like JavaScript that are designed to run in an asynchronous environment, but not usually seen in standard Lua. However, in Evo they are also used and there is no "good" way around them (but more on that later).'),(0,o.kt)("p",null,'To improve the usability of the resulting asynchronous code, Evo uses "events" directly to abstract callbacks where possible. So instead of passing around callback functions everywhere, you instead write event handlers that the runtime calls with specified parameters, allowing your program to handle the asynchronous task as needed. Whenever you see something like this, that\'s an event handler:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local server = HttpServer()\n\nfunction server:HTTP_REQUEST_FINISHED(event, payload)\n    -- Event handling code goes here\nend\n")),(0,o.kt)("p",null,"The conventions used are deliberately kept simple:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Each API namespace or module contains a list of events, as specified in the ",(0,o.kt)("a",{parentName:"li",href:"/docs/category/api/"},"API docs")),(0,o.kt)("li",{parentName:"ul"},"Events are written in capital letters, and every event handler has the same name as the event it handles"),(0,o.kt)("li",{parentName:"ul"},"In order to implement an event handler, you just set a function with the given event's name"),(0,o.kt)("li",{parentName:"ul"},"There are default event handlers (which usually do nothing, except print some debug information)"),(0,o.kt)("li",{parentName:"ul"},"Each event handler receives a ",(0,o.kt)("inlineCode",{parentName:"li"},"string")," containing the event name, and a payload ",(0,o.kt)("inlineCode",{parentName:"li"},"table")," as its arguments")),(0,o.kt)("p",null,"The exact contents of the payload table depend on the event used. Native (C++) events are internally translated to this format."),(0,o.kt)("h2",{id:"multithreading-and-the-event-loop"},"Multithreading and the Event Loop"),(0,o.kt)("p",null,"There is just one thread of execution in this asynchronous model. You can spawn other threads, and the event loop does internally use a pool of worker threads to complete the scheduled tasks more efficiently, but the basic model of programming is explicitly single-threaded: You do your work in the main Lua thread, and this thread sleeps when there's no async work to be done."),(0,o.kt)("p",null,"It only wakes up and notifies your program once an event has been triggered. Then, your program resumes: Tthe event loop notifies it via callbacks to handle all the events, before passing control back to the runtime (which checks for new events and goes back to sleep)."),(0,o.kt)("p",null,"If this seems a bit complicated, give it some time to sink it. As you work with asynchronous code more it'll become clearer."),(0,o.kt)("p",null,"The key takeway here is that running multiple threads in parallel is a completely different model of execution, with different trade-offs."),(0,o.kt)("h2",{id:"coroutines-and-the-event-loop"},"Coroutines and the Event Loop"),(0,o.kt)("p",null,"Lua features a concept called ",(0,o.kt)("a",{parentName:"p",href:"https://www.lua.org/pil/9.1.html"},"coroutines"),', which are lightweight "threads" that can be halted (and resumed) at will.'),(0,o.kt)("p",null,"They are indeed different from both threads and asynchronous work, but they can be used in Evo, to great effect. It's therefore important to understand how they interact with the event loop. Unlike threads, coroutines don't execute in parallel, but instead they behave more closely like asynchronous code that is \"woken up\" by the event loop, then goes back to sleep until more work is available."),(0,o.kt)("p",null,"You can, in fact, implement asynchronous code in a coroutine and send it to sleep (by ",(0,o.kt)("a",{parentName:"p",href:"https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield"},"yielding"),") until the async work has completed. Once new work is ready, the event loop can ",(0,o.kt)("a",{parentName:"p",href:"https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"},"resume")," your program. This somewhat alleviates the need for callbacks and events."),(0,o.kt)("p",null,"In a future version of Evo, this approach may be more prominent, but for the time being you'll have to experiment with it for yourself."),(0,o.kt)("p",null,"The most important thing to know is that coroutines still execute on the main thread, they just swap the currently-active function."))}d.isMDXComponent=!0}}]);