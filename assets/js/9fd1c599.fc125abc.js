"use strict";(self.webpackChunkevo_lua_github_io=self.webpackChunkevo_lua_github_io||[]).push([[6],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),d=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(n),m=i,p=h["".concat(o,".").concat(m)]||h[m]||u[m]||r;return n?a.createElement(p,s(s({ref:t},c),{},{components:n})):a.createElement(p,s({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:i,s[1]=l;for(var d=2;d<r;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9539:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return o},default:function(){return m},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return u}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),s=["components"],l={},o="RFC: Event Handling",d={unversionedId:"background-information/design/drafts/event-handling",id:"background-information/design/drafts/event-handling",title:"RFC: Event Handling",description:"This document details the design goals behind evo's event registry.",source:"@site/docs/background-information/design/drafts/event-handling.md",sourceDirName:"background-information/design/drafts",slug:"/background-information/design/drafts/event-handling",permalink:"/docs/background-information/design/drafts/event-handling",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/background-information/design/drafts/event-handling.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Drafts",permalink:"/docs/category/drafts"},next:{title:"RFC: Standardized Logging Framework",permalink:"/docs/background-information/design/drafts/logging-framework"}},c={},u=[{value:"Motivation",id:"motivation",level:2},{value:"Design Decisions",id:"design-decisions",level:2},{value:"Event Registry vs. Event Emitters",id:"event-registry-vs-event-emitters",level:3},{value:"Event Names",id:"event-names",level:3},{value:"Event Listeners",id:"event-listeners",level:3},{value:"Code Sharing",id:"code-sharing",level:3},{value:"Historical Context",id:"historical-context",level:2},{value:"Capitalized Event Names",id:"capitalized-event-names",level:3},{value:"Variable Number of Arguments",id:"variable-number-of-arguments",level:3},{value:"Network Messages and Events",id:"network-messages-and-events",level:3},{value:"Technical Constraints",id:"technical-constraints",level:2},{value:"Alternatives",id:"alternatives",level:2},{value:"References",id:"references",level:2}],h={toc:u};function m(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"rfc-event-handling"},"RFC: Event Handling"),(0,r.kt)("p",null,"This document details the design goals behind evo's event registry."),(0,r.kt)("h2",{id:"motivation"},"Motivation"),(0,r.kt)("p",null,"Asynchronous as well as synchronous events should be handled in a standardized and recognizable fashion."),(0,r.kt)("h2",{id:"design-decisions"},"Design Decisions"),(0,r.kt)("h3",{id:"event-registry-vs-event-emitters"},"Event Registry vs. Event Emitters"),(0,r.kt)("p",null,'Events can be handled with a global event registry ("event bus" pattern), or locally ("event emitter" pattern).'),(0,r.kt)("p",null,"Implications of using a global event registry:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A global API namespace must be provided (neutral)"),(0,r.kt)("li",{parentName:"ul"},"Every event emitter needs to hook into the registry (mild inconvenience)"),(0,r.kt)("li",{parentName:"ul"},"All events that fire can be observed and handled from anywhere (maximum flexibility)"),(0,r.kt)("li",{parentName:"ul"},"Can easily log events or otherwise track them, without missing any")),(0,r.kt)("p",null,"Implications of sticking to local event emitters instead:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each event emitter must handle its own events (neutral)"),(0,r.kt)("li",{parentName:"ul"},"Events are not observable to unrelated code (less flexible)"),(0,r.kt)("li",{parentName:"ul"},"Shared functionality needs to be outsourced to a mixin, or inherited (added complexity)")),(0,r.kt)("p",null,"A global event registry seems like it would be more flexible, simpler to implement, and easier to understand."),(0,r.kt)("h3",{id:"event-names"},"Event Names"),(0,r.kt)("p",null,"Events are always written in capital letters, like ",(0,r.kt)("inlineCode",{parentName:"p"},"APPLICATION_SHUTDOWN")," (WOW API style). The Node.js style of lower-case single-word event names (e.g.,  ",(0,r.kt)("inlineCode",{parentName:"p"},"shutdown"),") seems less flexible and readable in comparison."),(0,r.kt)("h3",{id:"event-listeners"},"Event Listeners"),(0,r.kt)("p",null,"All event handlers should have a standard name and signature, following the following conventions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The default event handler is always ",(0,r.kt)("inlineCode",{parentName:"li"},"OnEvent(eventID, eventInfo)")," , where ",(0,r.kt)("inlineCode",{parentName:"li"},"eventInfo")," is a table that contains the named keys and values of all passed arguments"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"eventInfo")," table should ",(0,r.kt)("em",{parentName:"li"},"not")," be an array, as that would defeat the point of making it easier to change the signature without having to update existing code that's unaffected by the changes"),(0,r.kt)("li",{parentName:"ul"},"This handler serves as a catchall, forwarding events to more specialized handlers (it can be overridden as needed)"),(0,r.kt)("li",{parentName:"ul"},"For each event, the name of its default handler is identical to the event ID written in PascalCase, with underscores removed and the event handler prefix ",(0,r.kt)("inlineCode",{parentName:"li"},"On")," preprended"),(0,r.kt)("li",{parentName:"ul"},"Example: ",(0,r.kt)("inlineCode",{parentName:"li"},"APPLICATION_SHUTDOWN")," is forwarded to  ",(0,r.kt)("inlineCode",{parentName:"li"},"MyObject:OnApplicationShutdown()")," by ",(0,r.kt)("inlineCode",{parentName:"li"},"MyObject:OnEvent()"))),(0,r.kt)("p",null,"Creating new ",(0,r.kt)("inlineCode",{parentName:"p"},"eventInfo")," tables doesn't seem to add any overhead, ",(0,r.kt)("a",{parentName:"p",href:"https://gist.github.com/Duckwhale/5685a0abe2930d563b4bc931a543b536"},"according to some very basic benchmarking"),"."),(0,r.kt)("p",null,"Since accessing the ",(0,r.kt)("inlineCode",{parentName:"p"},"eventInfo")," table ",(0,r.kt)("em",{parentName:"p"},"does")," have a measurable performance impact, and many event handlers will only care about the ",(0,r.kt)("inlineCode",{parentName:"p"},"eventID")," itself, it doesn't make sense to only pass an ",(0,r.kt)("inlineCode",{parentName:"p"},"eventInfo")," table with a ",(0,r.kt)("inlineCode",{parentName:"p"},"eventInfo.eventID")," field that would have to be read every time. When no arguments passed, there's also no table creation (possible GC churn)."),(0,r.kt)("h3",{id:"code-sharing"},"Code Sharing"),(0,r.kt)("p",null,"With a standardized approach to event handling, the core functionality can be outsourced to a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Mixin"},"mixin"),". This is preferable to direct inheritance as it removes the need for metatable lookups. These can be costly and aren't always well-optimized by the runtime. It also improves transparency because all methods are copied to the target, though this comes at the cost of some redundancy and leads to slightly higher memory usage per object. As Lua(JIT) generally has a low memory footprint, the trade-off is probably worth it, though some benchmarking would have to be done first."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://gist.github.com/Duckwhale/d3116b5c92f44c82b48ad3f2955b277b"},"Initial benchmarking")," suggests there may not be any difference in performance, at least in simple cases that can easily be optimized. However, having every object inherit from a single ancestor will lead to bloated hierarchies (see NodeJS) and doesn't play well with objects that already use metatables for other purposes, or are inherited from another object. For that reason, the initial version should simply use a mixin; this can always be re-evaluated later if the need arises."),(0,r.kt)("h2",{id:"historical-context"},"Historical Context"),(0,r.kt)("h3",{id:"capitalized-event-names"},"Capitalized Event Names"),(0,r.kt)("p",null,"Event emitters in NodeJS are generally less readable than they could be (like most JavaScript code...). Therefore, a more flexible naming scheme that supports adding information without sacrificing readability should be adopted. Since event names are effectively constants (enum values), capitalizing them only seems consistent with established C/Lua programming practice."),(0,r.kt)("h3",{id:"variable-number-of-arguments"},"Variable Number of Arguments"),(0,r.kt)("p",null,"In the original WOW API, event handlers would pass multiple values via varargs, like ",(0,r.kt)("inlineCode",{parentName:"p"},"OnEvent(eventID, ...)"),". This has proven to cause issues when signatures inevitably have to change, which is why arguments should be passed as an ",(0,r.kt)("inlineCode",{parentName:"p"},"eventInfo")," table. Entries should be indexed with the argument name, so that accessing missing fields raise a script error, and no changes need to be made to legacy code when new ones are added or unused properties are removed."),(0,r.kt)("h3",{id:"network-messages-and-events"},"Network Messages and Events"),(0,r.kt)("p",null,"Messages received from a remote peer can trigger events directly, and messages to be sent can trivially be constructed from events. This is (presumably) what happens in the World of Warcraft client, which indicates that the model fits well with a networked application such as a server based on libuv. Hence both NodeJS and WOW API are referenced here, with the goal of finding a design that hopefully improves on their weaknesses. A similar thing happens in JavaScript."),(0,r.kt)("h2",{id:"technical-constraints"},"Technical Constraints"),(0,r.kt)("p",null,"Because libuv provides the underlying event loop and it works with callbacks for asynchronous events, any implementation built on top of it can at best mask this fact. Event handlers then are merely callback functions in disguise, providing a slightly higher-level interface that can more easily be adapted to the problem domain."),(0,r.kt)("p",null,"The performance of handling large numbers of events will always be dictated by the overhead of Lua-C interactions (libuv callbacks), and by how well the underlying LuaJIT runtime manages to optimize a particular use case. There's no way around this short of writing C code directly, which is undesirable. This overhead is likely insignificant in many cases."),(0,r.kt)("h2",{id:"alternatives"},"Alternatives"),(0,r.kt)("p",null,"None, except using libuv callbacks exclusively. This results in somewhat unidiomatic Lua code, akin to JS. Not ideal."),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://nodejs.org/api/events.html"},"Events in Node.js")," (uses local event emitters)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://wowpedia.fandom.com/wiki/Events"},"Events in the World of Warcraft client")," (uses a global event registry bound to local objects)"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"http://docs.libuv.org/en/v1.x/design.html"},"libuv event loop")," will be the cause of callback-induced events")))}m.isMDXComponent=!0}}]);